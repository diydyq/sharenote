# [随记]重拾汇编语言知识点


## 什么是汇编语言？

汇编语言是一种人与计算机沟通的低级语言，以一种人可以方便记忆的方式指挥计算机做出各种操作。一步操作成为一条指令，因为简单或者复杂操作都是以指令为基本单位的；说其低级是因为我们需要人为的将复杂或简单操作一步步拆解为多条的基本指令，CPU无法读懂我们的业务目的，这就不想类似于Java等高级语言，提供了封装好的API供你调用，或者说：面向过程与面向对象的编程。

站在计算机的角度，它只会执行机器语言（机器码），但是这种仅有多个10组成的二进制语言，对我们的记忆是一种很大的负担，于是有了汇编语言，让人类读懂易写的时候，通过汇编语言编译器转换为机器语言；并且针对不同的CPU芯片，同样的指令所对应的机器语言可能是不同的，于是又有了针对汇编语言的抽象层：统一的指令集，适配到各平台，成为虚拟机。

所以，汇编语言与机器语言是两件东西，但两者是可以等价转换的，如：二进制的10B与十六进制的2H；等价的美元与人民币。

CPU与外围设备的通信类型，从逻辑上可以分为三类：控制信息，地址信息，数据信息；即：CPU让其他设备在什么地方（地址）以什么方式（控制）做什么事情（数据）。


## 寄存器 Register

在CPU运算器处理运算时，临时存储数据的地方叫：寄存器；分类如下：

1. 通用（General）寄存器：AX，BX，CX，DX；
2. 段式（Segment）寄存器：CS（Code Segment），DS（Data Segment），SS（Stack Segment），ES（Extra Segment）；
3. 标识（Flag）寄存器：ZF（Zero标志位），PF（Parity奇偶标志位），SF（Sign正负标志位：标识寄存器或者内存地址的正负），CF（进位标志位），OF（溢出标志位）

假设某CPU的寄存器是16位的（即：2的16次方的组合），每一个组合可以表示一个16位的地址，那总共可以表示64X1024个地址，1024个地址是1K个地址，即地址范围是1K，那总共就是64K的地址范围。但是实际上内存地址可能有1M的范围，使用20位的地址总线可以一次传输完成，但是本身该地址的保存就是一个问题。

为了解决这个16位寄存器访问超出64K地址范围的问题，科学家出了段式寻址的方式（Segment Addressing）,20位内存地址由两个寄存器组成，前者寄存器代表段地址（Segment），负责最高的4位，后者寄存器代表偏移地址（Offset），负责后面的16位；这样的话，段地址最大可以分为16段（2的4次方）,一个段的范围为64K（2的16次方）。

除了段式寻址，另外一种叫：平面内存模式（Flat Memory Modal），这种方式寄存器直接就可以覆盖内存的所有地址，因此无需分段。在X86-64架构中的long mode下，不在使用段式寻址，而是段长度强制为2的64次方，这个范围已经很大足够用。

段式寄存器的分类：
1. 指令寄存器（CS:IP（Code Segment：Instruction Pointer））：标识CPU开始执行指令的入口地址，不能通过MOV指令直接修改指令寄存器的值，可以通过：JMP 段地址:偏移地址或者 JMP 偏移地址的方式做段间跳转或者段内跳转，即：只修改IP或者同时修改CS与IP。
2. 栈寄存器（SS:SP（Stack Segment：Stack Pointer））：标识栈寄存器，后者标识栈顶地址
3. 数据寄存器（DS:SI（Data Segment：Source stream pointer））
4. 额外寄存器（ES:DI（Extra Segment：Destination stream pointer））

标志寄存器是按照其16位来做标识，其中每一位都有所定义的意义。


## 指令与伪指令

操作数据前，有一些数据需要进行预先定义，这些是被汇编语言的编译器识别的，称为伪指令。如：DW（Define word）:定义一个字（2个字节）；DD（Define doubleword）：定义双字（4个字节）；

loop指令是一个循环指令，需要与CX寄存器（Couter）配合；

ret与retf是返回指令，属于转移指令，分别代表段内返回与段间返回。ret的汇编实现大概如下：

1. 拿到该方法在上个方法的所处入口地址；因为在栈顶保存着，并赋给IP指令寄存器，即：IP = SS*16 + SP；
2. 栈pop移除一个元素，SP = SP + 2个字节；
3. CPU接下来根据IP寄存器指向的地址继续执行指令；

retf的汇编实现大概如下：
1. IP = SS*16 + SP
2. SP = SP + 2
3. CS = SS*16 + SP
4. SP = SP + 2
SP所指向的地址，即有可能是偏移地址SP，也有可能是段地址SS。

call指令的实现是这样的：
1. 将当前地址入栈：SP = IP
2. 栈元素加1：SP = SP - 2
3. 转移到新的地址执行


## 内中断与外中断

内中断是一种软件中断，由软件模拟，分类如下：
1. 被0除中断：INT 0
2. 单步中断：INT 1
3. 溢出中断：INTO 4：与其它中断不同的是，出现中断时不是由上条指令产生，而是由INTO指令产生
4. 断点中断：INT 3
5. 指令中断：INT N：软件中断调用；双字节中断指令：前者为操作码，后者为中断类型号；

中断发生并且必须响应时，就需要保存当前CPU执行现场（栈地址等），从**中断向量表**中通过标识寄存器中的中断码找到映射地址，作为IP指令入口地址。

外中断是有硬件引起的中断，可分为：可屏蔽中断，即：继续当前代码的执行，中断晚点执行；不可屏蔽中断；


## 多种寻址方式

当对地址采用多种方式访问时，采用的寻址方式也不同，这个在不同语言中也有差异，因为这是一个频繁操作，从而会有性能问题。

1. 直接寻址，如：[idata]
2. 寄存器间接寻址，如：[bx]
3. 寄存器相对寻址，如：[bx].idata访问结构体；idata[si]访问数组
4. 基址变址寻址，如：[bx][si]访问二维数组
5. 相对基址变址寻址，如：idata[bx][si]访问二维数组





## 参考资料

- [汇编语言（作者：王爽，第三版）](https://book.douban.com/subject/1215178/)
- [X86内存分段](https://en.wikipedia.org/wiki/X86_memory_segmentation)
- [汇编语言 WIKI](https://en.wikipedia.org/wiki/Assembly_language)
- [内部中断](http://baike.baidu.com/item/%E5%86%85%E9%83%A8%E4%B8%AD%E6%96%AD)
- []()
- []()
